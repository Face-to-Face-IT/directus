#!/usr/bin/env bash
set -euo pipefail

# Worktree Setup Script for directus
# Called by:
#   - Gas Town hooks: gt/<rig>/.runtime/setup-hooks/
#   - git gtr: via .gtrconfig postCreate hook
#
# Usage: .hooks/setup.sh [options]
#   --skip-install    Skip pnpm install
#   --skip-env        Skip .env generation
#   --skip-infra      Skip Docker infrastructure
#   --full            Run full setup including infra and bootstrap
#   --minimal         Only install deps and generate env (default)

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(dirname "$SCRIPT_DIR")"
WORKTREE_ROOT="${GT_WORKTREE_PATH:-$REPO_ROOT}"

# Defaults
SKIP_INSTALL=false
SKIP_ENV=false
SKIP_INFRA=true
FULL_SETUP=false

# Parse arguments
for arg in "$@"; do
    case $arg in
        --skip-install) SKIP_INSTALL=true ;;
        --skip-env) SKIP_ENV=true ;;
        --skip-infra) SKIP_INFRA=true ;;
        --full) FULL_SETUP=true; SKIP_INFRA=false ;;
        --minimal) SKIP_INFRA=true ;;
    esac
done

echo "üîß Setting up worktree: $WORKTREE_ROOT"

# -----------------------------------------------------------------------------
# Port Generation
# -----------------------------------------------------------------------------

get_worktree_index() {
    local current_path="$WORKTREE_ROOT"
    local index=0

    while IFS= read -r worktree_path; do
        if [[ "$worktree_path" == "$current_path" ]]; then
            echo "$index"
            return
        fi
        ((index++))
    done < <(git worktree list --porcelain 2>/dev/null | grep "^worktree " | cut -d' ' -f2-)

    # Fallback: use hash of path
    echo $(( $(echo "$current_path" | cksum | cut -d' ' -f1) % 100 ))
}

generate_ports() {
    local index=$(get_worktree_index)
    local port_offset=$((index * 100))

    # Base ports (from directus docker-compose)
    BASE_POSTGRES_PORT=5100
    BASE_DIRECTUS_PORT=8055
    BASE_REDIS_PORT=5105
    BASE_MINIO_PORT=5106

    POSTGRES_PORT=$((BASE_POSTGRES_PORT + port_offset))
    DIRECTUS_PORT=$((BASE_DIRECTUS_PORT + port_offset))
    REDIS_PORT=$((BASE_REDIS_PORT + port_offset))
    MINIO_PORT=$((BASE_MINIO_PORT + port_offset))

    echo "üìç Allocated ports (index: $index):"
    echo "   Postgres: $POSTGRES_PORT"
    echo "   Directus: $DIRECTUS_PORT"
    echo "   Redis: $REDIS_PORT"
    echo "   Minio: $MINIO_PORT"
}

generate_project_name() {
    local dir_name=$(basename "$WORKTREE_ROOT")
    echo "$dir_name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//;s/-$//'
}

# -----------------------------------------------------------------------------
# Setup Functions
# -----------------------------------------------------------------------------

setup_env() {
    local env_file="$WORKTREE_ROOT/api/.env"

    if [[ -f "$env_file" ]]; then
        echo "‚è≠Ô∏è  api/.env already exists, skipping"
        # Still read ports for other functions
        DIRECTUS_PORT=$(grep "^PORT=" "$env_file" | cut -d= -f2 || echo "8055")
        POSTGRES_PORT=$(grep "^DB_PORT=" "$env_file" | cut -d= -f2 || echo "5100")
        return
    fi

    generate_ports

    local project_name=$(generate_project_name)
    local secret=$(openssl rand -hex 32 2>/dev/null || head -c 32 /dev/urandom | xxd -p)

    echo "üìù Creating api/.env"
    mkdir -p "$WORKTREE_ROOT/api"
    cat > "$env_file" << EOF
# Auto-generated by .hooks/setup.sh
# Worktree: $WORKTREE_ROOT

# Server
PORT=$DIRECTUS_PORT
PUBLIC_URL=http://localhost:$DIRECTUS_PORT
SECRET=$secret

# Database
DB_CLIENT=postgres
DB_HOST=localhost
DB_PORT=$POSTGRES_PORT
DB_DATABASE=directus
DB_USER=postgres
DB_PASSWORD=secret

# Admin
ADMIN_EMAIL=admin@example.com
ADMIN_PASSWORD=directus

# Redis (optional)
# REDIS_HOST=localhost
# REDIS_PORT=$REDIS_PORT

# Minio (optional)
# STORAGE_LOCATIONS=s3
# STORAGE_S3_DRIVER=s3
# STORAGE_S3_KEY=minioadmin
# STORAGE_S3_SECRET=minioadmin
# STORAGE_S3_BUCKET=directus
# STORAGE_S3_ENDPOINT=http://localhost:$MINIO_PORT

# Docker
COMPOSE_PROJECT_NAME=$project_name
EOF

    echo "‚úÖ api/.env generated"
}

install_deps() {
    echo "üì¶ Installing dependencies..."
    cd "$WORKTREE_ROOT"
    pnpm install --frozen-lockfile 2>/dev/null || pnpm install
    echo "‚úÖ Dependencies installed"
}

build_packages() {
    echo "üî® Building packages..."
    cd "$WORKTREE_ROOT"
    pnpm build
    echo "‚úÖ Build complete"
}

start_infra() {
    echo "üê≥ Starting Docker infrastructure..."
    cd "$WORKTREE_ROOT"
    
    # Override ports via environment
    export POSTGRES_PORT
    docker compose up -d postgres
    
    # Wait for postgres to be ready
    echo "‚è≥ Waiting for Postgres..."
    for i in {1..30}; do
        if docker compose exec -T postgres pg_isready -U postgres >/dev/null 2>&1; then
            echo "‚úÖ Postgres is ready"
            return 0
        fi
        sleep 2
    done
    echo "‚ö†Ô∏è  Postgres may not be ready"
}

stop_infra() {
    echo "üõë Stopping Docker infrastructure..."
    cd "$WORKTREE_ROOT"
    docker compose down
}

bootstrap() {
    echo "üöÄ Running Directus bootstrap..."
    cd "$WORKTREE_ROOT/api"
    pnpm cli bootstrap
    echo "‚úÖ Bootstrap complete"
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    cd "$WORKTREE_ROOT"

    [[ "$SKIP_ENV" != true ]] && setup_env
    [[ "$SKIP_INSTALL" != true ]] && install_deps

    if [[ "$FULL_SETUP" == true ]]; then
        build_packages
        start_infra
        bootstrap
        echo ""
        echo "üéâ Full worktree setup complete!"
        echo "   Run 'cd api && pnpm dev' to start the API"
        echo "   Directus will be at http://localhost:$DIRECTUS_PORT"
    else
        echo ""
        echo "üéâ Worktree setup complete (minimal)!"
        echo "   Run '/dev start' or manually:"
        echo "   1. pnpm build"
        echo "   2. docker compose up -d postgres"
        echo "   3. cd api && pnpm cli bootstrap"
        echo "   4. cd api && pnpm dev"
    fi
}

main "$@"
